// Загрузка в metaspace класса на уровне Application, верификация кода, линковка ссылок на другие классы, вызываемые
// в коде. Статических полей и статических инициализаторов у данного класса нет.
public class JvmComprehension {
    // При вывозве main() в стеке создается новый фрейм
    public static void main(String[] args) {
        // Переменная i объявляется, инициализируется и помещается во фрейм main() стека
        int i = 1;
        // Объявляется ссылочная переменная типа Object. При создании объекта типа Object
        // вызывается загрузчик классов, который делегирует загрузку родительскому уровню,
        // если, конечно, этот класс не загружался ранее.
        // Вероятно, класс Object будет загружен в metaspace загрузчиком уровня Bootstrap. Загруженный
        // класс так же верифицируется, линкуется и инициализируется, помещается в кучу как
        // объект. Переменная o помещается в фрейм main() стека. В этой переменной хранится
        // ссылка на вновь созданный объект в куче.
        Object o = new Object();
        // Аналогично предыдущей строке, создается переменная ii типа Integer, помещается
        // в стек в фрейм main(). Благодаря механизму автоупаковки и приведению типов, после
        // загрузки в metaspace загрузчиком класса Integer, в куче создается объект класса
        // Integer, который инициализируется значением "2" через неявный вызов своего конструктора
        // В переменной ii хранится ссылка на объект типа Integer из кучи
        Integer ii = 2;
        // В стеке создается новый фрейм printAll()
        // Во фрейм сразу же помещаются локальные перменные o, i, ii типа Object, int и Integer
        // соответственно. i передается по значению, o и ii присваиваются ссылки на объекты
        // типа Object и Integer, созданные ранее в куче
        printAll(o, i, ii);
        // Работа этой строки кода аналогична строке номер шесть в исходном файле за исключением
        // отсутствия конкатенаций
        System.out.println("finished");
        // Полагаю, что к этому моменту стек становится пустым, сборщик мусора удаляет все из кучи
    }

    private static void printAll(Object o, int i, Integer ii) {
        // В фрейме printAll() в стек помещается переменная uselessVar типа Integer, в куче создается объект типа
        // Integer, проинициализированный значением 700. Ссылка на данный объект хранится в переменной
        // uselessVar
        // Класс Integer, вероятно, будет найден в метаспейсе и повторной загрузки не потребует
        Integer uselessVar = 700;
        // После загрузки загрузчиком класса System, инициализации и помещения его в metaspace, создастся
        // еще один фрейм при вызове метода println() у потока out (статическая переменная типа PrintStream), для которого ранее уже, вероятно, был загружен
        // класс PrintStream, для которого был загружен класс FilterOutputStream и т.д.
        // В качестве локальной переменной в этот фрейм передается ссылка на объект типа String, который создан в куче в результате
        // последовательных вызовов двух конкатенаций у объекта o, для которых так же, вероятно, было создано еще два фрейма в стеке
        // и т.д. На самом деле, предполагаю, что выстраивается очень сложное дерево вложенности вызовов
        // После выполнения метода происходит возврат к предыдущему фрейму стека 
        System.out.println(o.toString() + i + ii);  // 6
    }
}

